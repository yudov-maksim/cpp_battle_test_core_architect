# модули/подсистемы и их ответственность
- **Представлено на диаграмме components.puml**
    - Initializer: модуль инициализации
        - создает и настраивает движок, добавляет юниты
    - GameEngine: игровой движок
        - управляет симуляцией, отвечая за логику игры (старт, новый "шаг-раунд", завершение)
    - GameMap: карта с игровым миром
        - хранит юниты
        - определяет логику шага симуляции
    - Unit: представление игровых юнитов
        - абстрактный класс для работы с юнитами. Содержит общие для юнитов свойства и методы
        - отличие будут реализованы в классах-наследниках
    - BehaviorStrategy: логика действий юнитов
    - EventLog: подсистема, отвечающая за отображение (логирование) событий

# применяемые паттерны проектирования
- Шаблонный метод
    - позволит реализовать шаблон/каркас хода, но оставить реализацию отличающихся действий на конкретные подклассы
- Стратегия
    - позволит менять поведение в зависимости от типа юнита
- Наблюдатель
    - позволит подписаться на обновления / действия юнита и залогировать их
- Фабрика
    - позволит генерировать новые типы юнитов, практически не изменяя код, реализующий работу с созданием юнитов
- Команда (потенциально)
    - позволит легче логировать действия
    - создаст базу для работы с последовательностью действий (повторение, отмена)

# как будет расширяться функциональность
**Система разделена на модули, пожтому общее расширение сводится к расширению конкретных частей системы**
- типы юнитов: добавить класс, унаследованный от Unit, с нужным поведением
- действия: реализовать новые методы (например, лечение)
    - за счёт своей реализации виртульаного метода take_turn новое действие будет добавляться без особых проблем
- характеристики: добавить свойства объекта (мемберы класса)
    - свойства будут учитываться в своей реализации виртуальных методов - например, move (невозможность передвижения для башни) 
- новая логика поведения: использовать паттерн "Стратегия"
- управдение симуляцией: заменить take_turn() на команды, полученные извне
- развитие картоы и работы с ней: установка непроходимых объектов, загрузка из файла
- добавление инициативы юнитов: ходы не по порядку создания, а по показателю инициативы

# порядок обработки команд/событий за ход
Т.к. юниты сохраняются в контейнер последовательно в порядке создания, то и проверка очередности их действий не нужна. Но для потенциального ращвития и добавления инициативы, шаг сделаем сразу.

- 1. обработка очереди юнитов:
    - для каждого живого юнита согласано его приоритету (очередности создания / инициативе) вызывается его действие
- 2. действие юнита:
    - выполняет своё действие, если возможно (атака, лечение)
    - иначе: движется к цели (или согласно имеющемуся алгоритму движения)
        - при движении осуществляется проверка выхода за границы и возмоности остановиться в выбранной клетке (не занята ли она)
- 3. удаление юнитов с hp <= 0
    - Рассматриваю конец хода как допустимую трактовку условия "Если **HP** ≤ 0, юнит исчезает на следующий ход и больше не действует.", тк важно удаление юнита именно после действий остальных юнитов
- 4. Проверка условий завершения:
 - 0 или 1 юнит, способный действовать — конец игры.

# аргументацию выбранных решений
- Объектно-ориентированная модель
    - ООП язык (с++) задан заранее. Но если бы и не был задан:
    - модель игры и юниты логично вписываются в ООП парадигму, позволяя выстраивать модульную архитектуру с разделением ответственности
    - полиморфизм юнитов через take_turn
        - позволяет легко расширять поведение, не усложняя GameMap
- Разделение ответственности
    - упрощает читаемость кода, его развитие и тестирование
- Выбор паттернов проектирования обоснован в разделе с их перечислением
- Простая карта W×H с клетками
    - задание прямо говорит об отсутствии необходимости усложнения карты
